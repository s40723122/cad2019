<h1>About</h1>
<p>此內容管理系統以 <a href="https://github.com/mdecourse/cmsimde">https://github.com/mdecourse/cmsimde</a> 作為 submodule 運作, 可以選定對應的版本運作, cmsimde 可以持續改版, 不會影響之前設為 submodule, 使用舊版 cmsimde 模組的內容管理相關運作.</p>
<h4>利用 cmsimde 建立靜態網誌方法:</h4>
<p>1. 在 github 建立倉儲, git clone 到近端</p>
<p>2. 參考 <a href="https://github.com/mdecourse/newcms">https://github.com/mdecourse/newcms</a>, 加入除了 cmsimde 目錄外的所有內容</p>
<p>以 git submodule add <a href="https://github.com/mdecourse/cmsimde">https://github.com/mdecourse/cmsimde</a> cmsimde</p>
<p>建立 cmsimde 目錄, 並從 github 取下子模組內容.</p>
<p>3.在近端維護時, 更換目錄到倉儲中的 cmsimde, 以 python wsgi.py 啟動近端網際伺服器.</p>
<p>動態內容編輯完成後, 以 generate_pages 轉為靜態內容, 以 git add commit 及 push 將內容推到遠端.</p>
<p>4. 之後若要以 git clone 取下包含 submodule 的所有內容, 執行:</p>
<p>git clone --recurse-submodules <a href="https://github.com/mdecourse/newcms.git">https://github.com/mdecourse/newcms.git</a></p>
<h1>Develop</h1>
<p><a href="https://github.com/mdecourse/cmsimde">https://github.com/mdecourse/cmsimde</a> 的開發, 可以在一個目錄中放入 cmsimde, 然後將 up_dir 中的內容放到與 cmsimde 目錄同位階的地方, 使用 command 進入 cmsimde 目錄, 執行 python wsgi.py, 就可以啟動, 以瀏覽器 https://localhost:9443 就可以連接, 以 admin 作為管理者密碼, 就可以登入維護內容.</p>
<p>cmsimde 的開發採用 Leo Editor, 開啟 cmsimde 目錄中的 cmsimde.leo 就可以進行程式修改, 結束後, 若要保留網際內容, 只要將 cmsimde 外部的內容倒回 up_dir 目錄中即可後續對 cmsimde 遠端倉儲進行改版.</p>
<p>init.py 位於  up_dir 目錄, 可以設定 site_title 與 uwsgi 等變數.</p>
<p>先將 Y:\portablegit\bin\sh.exe 改名為 sh_rename_for_solvespace.exe</p>
<h1>Solvespace</h1>
<p>git version 查驗 git 版本</p>
<p>git 2.13 版本以上, 可以使用下列 git clone <span>--recurse-submodules 取得所有子模組資料</span></p>
<p>git clone --recurse-submodules https://github.com/solvespace/solvespace.git solvespace</p>
<p>edit Y:\tmp\solvespace\extlib\angle\CMakeLists.txt comment out line 713 and 714</p>
<p>#list(APPEND ANGLE_DEFINITIONS<br/>#"-DANGLE_PRELOADED_D3DCOMPILER_MODULE_NAMES={ \"d3dcompiler_47.dll\", \"d3dcompiler_46.dll\", \"d3dcompiler_43.dll\" }")<br/>endif()</p>
<p>需要手動進行 libpng.dll.a 的編譯, 並改名為 libpng_static.a, 並放到編譯系統的 lib 目錄中:</p>
<p>cd solvespace</p>
<p>cd extlib</p>
<p>cd libpng</p>
<p>mkdir build</p>
<p>cd build</p>
<p>cmake .. -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=Release<br/>mingw32-make</p>
<p>rename libpng.dll.a to libpng_static.a and copy to Y:\msys64\mingw64\lib</p>
<p>接著回到 solvespace 原始碼目錄, 建立 build 目錄後進入 build 目錄, 執行:</p>
<p><span>cmake .. -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=Release</span><br/><span>mingw32-make</span></p>
<p><span></span></p>
<h1>Solvespace</h1>
<p></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/wyACVTz4RW4" width="560"></iframe></p>
<h1>week15</h1>
<p><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="693" src="https://www.youtube.com/embed/3ppnNWs44Rc" width="1280"></iframe></p>
<h1>week16</h1>
<p></p>
<p><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="693" src="https://www.youtube.com/embed/Gm7cGnUzRYI" width="1280"></iframe></p>
<h1>week17</h1>
<p>building the joints</p>
<p>Now we will take care of the joints/motors. Most of the time, we know the exact position and orientation of each of the joints. In that case, we simply add the joints with [Menu bar --&gt; Add --&gt; Joints --&gt; ...], then we can change their position and orientation with the <span><a href="http://www.coppeliarobotics.com/helpFiles/en/positionDialog.htm">position dialog</a></span> and <span><a href="http://www.coppeliarobotics.com/helpFiles/en/orientationDialog.htm">orientation dialog</a></span>. In other situations, we only have the Denavit-Hartenberg (i.e. D-H) parameters. In that case, we can build our joints via the tool model located in <em>Models/tools/Denavit-Hartenberg joint creator.ttm</em>, in the model browser. Othertimes, we have no information about the joint locations and orientations. Then, we need to extract them from the imported mesh. Let's suppose this is our case. Instead of working on the modified, more approximate mesh, we open a new scene, and import the original CAD data again. Most of the time, we can extract meshes or primitive shapes from the original mesh. The first step is to subdivide the original mesh. If that does not work, we do it via the <span><a href="http://www.coppeliarobotics.com/helpFiles/en/triangleEditMode.htm">triangle edit mode</a></span>. Let's suppose that we could divide the original mesh. We now have smaller objects that we can inspect. We are looking for revolute shapes, that could be used as reference to create joints at their locations, with the same orientation. First, remove all objects that are not needed. It is sometimes also useful to work across several opened scenes, for easier visualization/manipulation. In our case, we focus first on the base of the robot: it contains a cylinder that has the correct position for the first joint. In the triangle edit mode, we have:</p>
<p><strong>建立關節</strong></p>
<p><strong>現在我們要來關注關節以及發動機，大多時候，我們知道各個關節間準確的位置和方向。因此，我們簡單的用</strong>[Menu bar --&gt; Add --&gt; Joints --&gt; ...]<strong>加入關節，然後我們可以利用</strong><span><a href="http://www.coppeliarobotics.com/helpFiles/en/positionDialog.htm">position dialog</a></span><strong>和</strong> <span><a href="http://www.coppeliarobotics.com/helpFiles/en/orientationDialog.htm">orientation dialog</a></span>.<strong>改變他們的位置和方向。在其他情況下，我們只有</strong>Denavit-Hartenberg<strong>參數。在這種情況下，在模型瀏覽器中，我們可以建立關節通過位於</strong><strong>Models/tools/Denavit-Hartenberg joint creator.ttm</strong><strong>中的工具模型。有時我們沒有關於關節方向和位置的資訊。因此，我們需要從導入的</strong><strong>mesh</strong><strong>中叫出他們。假設這是我們的情形，不用在更改和更多近似的</strong><strong>mesh</strong><strong>上做改變，我們打開一個新介面，然後再次導入原始的</strong><strong>CAD</strong><strong>數據。大多時候，我們可以從原始</strong><strong>mesh</strong><strong>中提取</strong><strong>mesh</strong><strong>或原始形狀。第一步是細分原始</strong><strong>mesh</strong><strong>，如果沒有用，我們將用</strong><strong>triangle edit</strong><strong>模式進行。假設我們可以劃分原始</strong><strong>mesh</strong><strong>，現在，我們現在可以檢查更小的物件。我們正在尋找可以用來建立關節在哪個位置的參考，有著一樣取向的旋轉形狀。首先，刪除所有不需要的物件。有時，在好幾個不同的介面中工作也很有用，可以更簡單的視覺化。在我們的案例中，我們首先關注機器人的基底，包含了一個給第一個關節正確位置的圓柱體。在</strong><strong>triangle edit</strong><strong>模式中，我們有</strong><strong>:</strong></p>
<p style="line-height: 15.6pt; background: white; margin: 5.0pt 36.0pt 5.0pt 36.0pt;"><span lang="EN-US" style="font-size: 13.5pt; font-family: 'Tahoma',sans-serif; color: #5c5c5c;">We change the camera view via the </span><span lang="EN-US"><a href="http://www.coppeliarobotics.com/helpFiles/en/userInterface.htm#toolbars"><span style="font-size: 13.5pt; font-family: 'Tahoma',sans-serif; color: #1919b0;">page selector</span></a></span><span lang="EN-US" style="font-size: 13.5pt; font-family: 'Tahoma',sans-serif; color: #5c5c5c;"> </span><span lang="EN-US"><a href="http://www.coppeliarobotics.com/helpFiles/en/userInterface.htm#toolbars"><span style="font-size: 13.5pt; font-family: 'Tahoma',sans-serif; color: #1919b0;">toolbar button</span></a></span><span lang="EN-US" style="font-size: 13.5pt; font-family: 'Tahoma',sans-serif; color: #5c5c5c;">, in order to look at the object from the side. The </span><span lang="EN-US"><a href="http://www.coppeliarobotics.com/helpFiles/en/userInterface.htm#toolbars"><span style="font-size: 13.5pt; font-family: 'Tahoma',sans-serif; color: #1919b0;">fit-to-view toolbar button</span></a></span><span lang="EN-US" style="font-size: 13.5pt; font-family: 'Tahoma',sans-serif; color: #5c5c5c;"> can come in handy to correctly frame the object in edition. Then we switch to the </span><span lang="EN-US"><a href="http://www.coppeliarobotics.com/helpFiles/en/vertexEditMode.htm"><span style="font-size: 13.5pt; font-family: 'Tahoma',sans-serif; color: #1919b0;">vertex edit mode</span></a></span><span lang="EN-US" style="font-size: 13.5pt; font-family: 'Tahoma',sans-serif; color: #5c5c5c;"> and select all vertices that belong to the upper disc. Remember that by switching some </span><span lang="EN-US"><a href="http://www.coppeliarobotics.com/helpFiles/en/layerSelectionDialog.htm"><span style="font-size: 13.5pt; font-family: 'Tahoma',sans-serif; color: #1919b0;">layers</span></a></span><span lang="EN-US" style="font-size: 13.5pt; font-family: 'Tahoma',sans-serif; color: #5c5c5c;"> on/off, we can hide other objects in the scene. Then we switch back to the triangle edit mode:<o:p></o:p></span></p>
<p><strong>我們利用頁面中的選擇工具按鈕改變相機的視角，以便從側邊看物件。適合查看的工具欄按鈕可以派上用場，以可以建構在版本中的物件。然後，我們切換到</strong><strong>vertex edit</strong><strong>模式，選擇所有在上碟裡的所有端點。記住，打開或關閉圖層時，我們會隱藏到圖層中的物件。</strong></p>
<p><strong>然後，我們切換回</strong>triangle edit<strong>模式</strong><strong>:</strong></p>
<p>Now we click <strong>Extract cylinder</strong> (<strong>Extract shape</strong> would also work in that case), this just created a cylinder shape in the scene, based on the selected triangles. We leave the edit mode and discard the changes. Now we add a revolute joint with [Menu bar --&gt; Add --&gt; Joint --&gt; Revolute], keep it selected, then control-select the extracted cylinder shape. In the <span><a href="http://www.coppeliarobotics.com/helpFiles/en/positionDialog.htm">position dialog</a></span>, on the <strong>position</strong> tab, we click <strong>Apply to selection</strong>: this basically copies the x/y/z position of the cylinder to the joint. Both positions are now identical. In the <span><a href="http://www.coppeliarobotics.com/helpFiles/en/orientationDialog.htm">orientation dialog</a></span>, on the <strong>orientation</strong> tab, we also click <strong>Apply to selection</strong>: the orientation of our selected objects is now also the same. Sometimes, we will need to additionally rotate the joint about 90/180 degrees around its own reference frame in order to obtain the correct orientation or rotation direction. We could do that on the <strong>rotation</strong> tab of that dialog if needed (in that case, do not forget to click the <strong>Own frame</strong> button). In a similar way we could also shift the joint along its axis, or even do more complex operations. This is what we have:</p>
<p><strong>現在，我們點擊提取圓柱體</strong><strong>(</strong><strong>提取形狀也會開始運作</strong><strong>)</strong><strong>，這只是根據選取的三角形，在介面中創造一個圓柱體。離開編輯模式並放棄更改。現在我們利用</strong>[Menu bar --&gt; Add --&gt; Joint --&gt; Revolute]<strong>新增一個旋轉關節，讓他保持選定，然後選取提取的圓柱體。在</strong><strong>”</strong><strong>位置</strong><strong>”</strong><strong>選項中，點擊</strong><strong>”</strong><strong>應用到選擇</strong><strong>”:</strong><strong>這基本上會將圓柱體上的</strong><strong>x/y/z</strong><strong>位置複製到關節上。兩個位置現在都相同了。在方向介面中，我們也點擊</strong><strong>”</strong><strong>運用到選擇</strong><strong>”:</strong><strong>我們選擇的物件的方向現在也相同了。有時，我們需要選轉關節</strong><strong>90/180</strong><strong>度，以獲得正確的方向或旋轉方向。如果需要的話，我們也可以在旋轉鍵上執行此操作</strong><strong>(</strong><strong>這種情況下，別忘記點擊</strong><strong>own frame</strong><strong>鍵</strong><strong>)</strong><strong>。同樣，我們也可以沿著關節的軸移動關節，甚至進行更複雜的操作，這是我們有的</strong><strong>:</strong></p>
<p><strong>Now we copy the joint back into our original scene, and save it (do not forget to save your work on a regular basis! The undo/redo function is useful, but doesn't protect you against other mishaps). We repeat above procedure for all the joints in our robot, then rename them. We also make all joints a little bit longer in the <a href="http://www.coppeliarobotics.com/helpFiles/en/jointProperties.htm">joint properties</a>, in order to see them all. By defaut, joints will be assigned to visibility layer 2, but can be changed in the <a href="http://www.coppeliarobotics.com/helpFiles/en/commonPropertiesDialog.htm">object common properties</a>. We assign now all joints to visibility layer 10, then temporarily <a href="http://www.coppeliarobotics.com/helpFiles/en/layerSelectionDialog.htm">enable visibility layer 10 for the scene</a> to also visualize those joints (by default, only visibility layers 1-8 are activated for the scene). This is what we have (the model <em>ResizableFloor_5_25</em> was temporarily made invisible in the <a href="http://www.coppeliarobotics.com/helpFiles/en/modelDialog.htm">model properties dialog</a>): </strong></p>
<p><strong>現在，我們將關節複製回我們原始的介面中，並儲存</strong><strong>(</strong><strong>不要忘記定期保存你的工作進度</strong><strong>!</strong><strong>返回功能很有用，但不能保護你免於其他事故的影響</strong><strong>)</strong><strong>。對機器人中所有關節重複以上的動作，然後重新命名他們。我們也將所有關節的關節屬性變長一點，以便查看所有的關節，默認中，關節將會被分配在可見圖層</strong><strong>2</strong><strong>，但是可以在公共屬性中進行更改。現在，我們將所有關節改道圖層</strong><strong>10</strong><strong>，然後只將圖層</strong><strong>10</strong><strong>可見性打開</strong><strong>(</strong><strong>默認情況下，只會看見圖層</strong><strong>1-8)</strong><strong>。這就是我們所擁有的，</strong><strong>(</strong><strong>模型</strong><em>ResizableFloor_5_25</em> <strong>在模型屬性中暫時不可見</strong><strong>):</strong></p>
<p style="line-height: 15.6pt; background: white; margin: 5.0pt 36.0pt 5.0pt 36.0pt;"><span lang="EN-US" style="font-size: 13.5pt; font-family: 'Tahoma',sans-serif; color: #5c5c5c;">At this point, we could start to build the model hierarchy and finish the model definition. But if we want opur robot to be </span><span lang="EN-US"><a href="http://www.coppeliarobotics.com/helpFiles/en/designingDynamicSimulations.htm"><span style="font-size: 13.5pt; font-family: 'Tahoma',sans-serif; color: #1919b0;">dynamically enabled</span></a></span><span lang="EN-US" style="font-size: 13.5pt; font-family: 'Tahoma',sans-serif; color: #5c5c5c;">, then there is an additional intermediate step:<o:p></o:p></span></p>
<p><strong>至此，我們可以開始建立模型層次並完成模型定義。但是，如果我們希望啟用</strong><strong>opur</strong><strong>機器人，則還有另一個中間步驟</strong><strong>:</strong></p>